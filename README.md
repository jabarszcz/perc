perc
=====

An erlang record codec generator. `perc` uses erlang record
definitions and user type definitions to generate efficient record
encoding NIFs.

A small benchmark comparing it to [jiffy][jiffy] can be found
[here][perc_vs_jiffy].

There is also a [rebar3 plugin][plugin] to build the codecs at build time.

PERC stands for *Producer of Erlang Record Codecs*.

[jiffy]: https://github.com/davisp/jiffy
[perc_vs_jiffy]: https://github.com/jabarszcz/perc_vs_jiffy
[plugin]: https://github.com/jabarszcz/rebar3_perc_plugin

Deps
----

`perc` requires rebar3 to build. You will also need a c++ compiler to
compile the nifs generated by perc.

Build
-----

    $ rebar3 escriptize

Run
---
```
 Usage: _build/default/bin/perc [-e [<erl_out>]] [-c [<cpp_out>]]
             [-i <input_file>] [-r <record>] [-b [<backend>]]

   -e, --erl-out  The generated erlang module name [default: generated]
   -c, --cpp-out  The generated cpp file name [default: generated]
   -i, --in       An erlang file containing type and record definitions
   -r, --record   The records for which we want an encoding function
   -u, --usertype  The user types for which we want an encoding function
   -b, --backend  The codec backends (json, etc.) [default: json]
```

This will write an erlang module to `<erl_out>.erl` and the C++ NIFs
to `<cpp_out>.cpp`. You can then compile the C++ NIFs with:

```
g++ -fvisibility=hidden -nodefaultlibs -o <cpp_out>.so -fpic -shared \
    <cpp_out>.cpp -I $ERL_ROOT/usr/include/ -I $PERC_PATH/c_include/
```

The erlang module can then be used to encode records:

```
> <erl_out>:<backend>_encode_record_<record>(#<record>{}).
> generated:json_encode_record_test_rec(#test_rec{}).
```

It is possible to put multiple input files and records by repeating
the options with each argument. For example, this will export NIFs for
`recorda` and `recordb`, both defined in `recorddefs.hrl` even if the
definitions depend on other type/record definitions found in
`somedeps.hrl`.

```
$ _build/default/bin/perc -i recorddefs.hrl -i somedeps.hrl \
$     -r recorda -r recordb
```

> **Note:** Right now, only encoding is possible and the only backend is json.

Type translation
----------------

`perc` uses source code type information and (eventually) commented
annotations to decide how to encode/decode the fields of records. For
the purposes of translation between erlang and the backend, `perc` has
an internal representation of types.

#### Ignored

Some types are ignored or not understood by `perc`:

> `any()`, `none()`, `pid()`, `port()`, `reference()`, `fun(...)`,
>  `<module>:<type>`

They are ignored in the translation and a comment in the C++ file will
indicate the reason of their absence.

#### Basic types

`integer`, `float`, `atom`, `binary`, `string` and `boolean`

> **Note:** Binaries should already be encoded in utf8 for json.

#### Maybe

Type unions that contain the atom undefined add a check at runtime: if
the field is undefined, it will be omitted from the json.

#### Unions

Type unions are checked one type at a time, in order, so they add some
time in the encoding.

> **Note:** It might not make sense to have unions of types that map
> to the same json types. For instance `atom() | string()` would be
> ambiguous at the decoding stage, although the decoding is not
> implemented yet.

#### Other compound types

Lists, tuples and unions can be arbitrarily nested.

#### Records and user-defined types

The types used to define record fields and user types can recursively
be defined in terms of records and user types.

Types can also be recursive, as this integer tree:

```
-type tree() :: integer() | [tree()].
```

> **Note:** `perc` does not understand modules, so the syntax
>     `<module>:<type>` will lead to ignored fields.

> Handling of type parameters for user-defined types has not been
> implemented yet.

### Comments

For cases where `perc` is not able to understand the erlang type spec,
it will eventually parse a special comment syntax to override the
typespec.
