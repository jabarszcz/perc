{% autoescape off %}
template <>
int json_encoder<{{ name_template }}>::encode(
    struct encoder *e,
    const ERL_NIF_TERM term)
{% templatetag openbrace %}
    size_t index = e->index;
    bool is_first=true;
    int arity, n_encoded=0;
    const ERL_NIF_TERM *fields;
    if (!enif_get_tuple(e->env, term, &arity, &fields))
        goto fail;
    if (!enif_is_identical(enif_make_atom(e->env, "{{ name }}"), fields[0]))
        goto fail;
    if (!json_enc_begin_obj(e))
        goto fail;
{% for field in fields %}
{% if field.ignored %}
    // Field {{ field.index }} ({{ field.name }}) ignored;
    {% for line in field.ignored_reason_lines %}
    // {{ line }}{% endfor %}
{% else %}
    if (true{% for filter in field.filters %}
      && {{ filter }}(e->env, fields[{{ field.index }}], e->opts){% endfor %}
      ) {
        size_t before_field_idx = e->index;
        if (!JSON_ENC_KEY(e, is_first, "{{ field.name }}"))
            goto fail;
        int ret = json_encode<{{ field.type_template }}>(
            e,
            fields[{{ field.index }}]
        );
        if (ret < 0)
            goto fail;
        {% if field.no_empty_obj %}
        if (!ret) {
            e->index = before_field_idx;
        } else {
            n_encoded++;
        }
        {% else %}
        n_encoded++;
        {% endif %}
    }
{% endif %}
{% endfor %}
    if (!json_enc_end_obj(e))
        goto fail;
    return n_encoded;
fail:
    e->index = index;
    return -1;
{% templatetag closebrace %}
{% endautoescape %}
